- [多路复用、多路分解](#多路复用多路分解)
  - [无连接多路分解](#无连接多路分解)
  - [面向连接多路分解](#面向连接多路分解)
- [TCP & UDP](#tcp--udp)
  - [UDP报文](#udp报文)
  - [TCP报文](#tcp报文)
- [TCP 建立连接](#tcp-建立连接)
  - [三次握手](#三次握手)
  - [为什么三次握手？](#为什么三次握手)
  - [第2次握手传回了ACK，为什么还要传回SYN？](#第2次握手传回了ack为什么还要传回syn)
- [TCP释放连接](#tcp释放连接)
  - [四次挥手](#四次挥手)
  - [为什么四次挥手？](#为什么四次挥手)
- [TCP粘包/拆包问题](#tcp粘包拆包问题)
  - [什么是粘包问题？](#什么是粘包问题)
  - [为什么会发生粘包问题？](#为什么会发生粘包问题)
  - [什么时候会出现粘包/拆包问题？](#什么时候会出现粘包拆包问题)
  - [解决方案](#解决方案)
- [TCP协议如何保证可靠传输？](#tcp协议如何保证可靠传输)
- [ARQ协议](#arq协议)
    - [停止等待ARQ协议](#停止等待arq协议)
    - [连续ARQ协议](#连续arq协议)
- [滑动窗口机制](#滑动窗口机制)
  - [Go-Back-N](#go-back-n)
  - [Selective Repeat](#selective-repeat)
- [TCP拥塞控制](#tcp拥塞控制)






![image-20200830001635627](https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200830001637.png)



## 多路复用、多路分解



- **运输层**它的作用是提供**进程之间**的通信，**应用层**则是最顶层，作用是为用户提供与网络打交道的接口。应用层与运输层之间通过**套接字**传递数据，套接字是运输层与应用层的一个中间媒介，位于两层之间。

- 运输层接收到数据后，将它交付到正确的套接字中，应用层进程从的相应的套接字中获取数据

- 反之应用层将数据交付到套接字，运输层从套接字中收集数据。而网络层接收其他主机发送的数据，去除首部信息后交给运输层，由运输层定向到套接字；反之运输层也将从套接字中收集的数据封装后，交给网络层向下传递。

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829160101.png" width = "700", height = "200"></img></div>

- **多路复用**：在数据的发送端，传输层收集各个套接字中需要发送的数据，将它们封装上首部信息后（之后用于分解），交给网络层；
- **多路分解**：在数据的接收端，传输层接收到网络层的报文后，将它交付到正确的套接字上



### 无连接多路分解

> UDP 套接字由两个因素指定:(目的IP地址, 目的端口号)



<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829160651.png" width = "700", height = "400"></img></div>

当主机收到UDP数据段:

- 检查数据段中的目的端口号
- 用端口号指示UDP数据段属于哪个套接字
- 具有不同的源IP地址且/或源端口号，但**具有相同的目的IP地址和目的端口号的IP数据报，指向同样的套接字**



### 面向连接多路分解

> TCP 套接字由4部分指定: (源IP地址, 源端口号, 目的IP地址, 目的端口号)，接收主机使用所有四个值将数据段定位到合适的套接字



<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829160936.png" width = "700", height = "350"></img></div>



## TCP & UDP

| 类型 | 是否面向连接 | 传输可靠性 |  传输形式  | 传输效率 | 所需资源 |   应用场景   | 首部大小 |
| :--: | :----------: | :--------: | :--------: | :------: | :------: | :----------: | :------: |
| TCP  |      是      |    可靠    |   字节流   |    慢    |    多    | 通信数据可靠 |  20-60   |
| UDP  |      否      |   不可靠   | 数据报文段 |    快    |    少    |  通信速度高  |  8字节   |



### UDP报文

用户数据报 UDP 有两个字段

- 数据字段
- 首部字段：首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节
  - 源端口
  - 目的端口
  - 长度
  - 检验和

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829163256.png" width = "800", height = "350"></img></div>

UDP数据包最大长度为64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号



### TCP报文



<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829163949.png" width = "800", height = "500"></img></div>

- **源端口和目的端口字段**：各占 2 字节；端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 表示数据是从哪个进程来, 到哪个进程去
- **序号字段**：占 4 字节，TCP 连接中**传送的数据流中的每一个字节都编上一个序号**。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号
- **确认号字段**：占 4 字节，是**期望收到对方的下一个报文段的数据的第一个字节的序号**
- **数据偏移（即首部长度）**：占 4 位，它指出 TCP 报文段的**数据起始处距离 TCP 报文段的起始处有多远**。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）
- **保留字段**：占 6 位，保留为今后使用，但目前应置为 0
- **紧急 URG** ：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)
- **确认 ACK**：只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效
- **PSH**：提示接收端应用程序立刻从TCP缓冲区把数据读走
- **复位 RST**：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接
- **同步 SYN**：同步 SYN = 1 表示这是一个连接请求或连接接受报文
- **终止 FIN**：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接
- **窗口字段** ：占2字节，用来让对方设置发送窗口的依据，单位为字节
- **检验和**：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部
- **紧急指针字段**：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）
- **填充字段**：这是为了使整个首部长度是 4 字节的整数倍



## TCP 建立连接



### 三次握手

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829172524.png" width = "800", height = "400"></img></div>

- 客户端发送带有 SYN 标志的数据包
  - 指定初始序号，没有数据
- 服务器接收SYN, 回复 SYN/ACK 报文段
  - 服务器分配缓冲区
  - 指定服务器的初始序号
- 客户接收 SYN/ACK, 回复 ACK 报文段, 可能包含数据



### 为什么三次握手？

- **三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**
  - 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
  - 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
  - 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常
  - **所以三次握手就能确认双发收发功能都正常，缺一不可**

- **防止失效的连接请求到达服务器，让服务器错误打开连接**
  - 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接

### 第2次握手传回了ACK，为什么还要传回SYN？

接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传**SYN则是为了建立并确认从服务端到客户端的通信**。



## TCP释放连接



### 四次挥手

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829172611.png" width = "700", height = "400"></img></div>

- **客户发送释放报文**：FIN  = 1, seq = x​ 控制报文段到服务器，这时A进入FIN-WAIT-1​(终止等待1)状态，等待服务器端的确认。

- **服务器接收 FIN：回复 ACK = x + 1**， 半关闭连接，并发送FIN到客户，**然后服务器端就进入CLOSE-WAIT(关闭等待)状态，此时的TCP连接处于半关闭状态，即客户端已经没有数据要发送了，但服务器端若发送数据，客户端仍要接受**
- **客户端接收服务器端报文等待释放连接**：此时客户端进入FIN-WAIT-2(终止等待2)状态，等待服务器端发出的连接释放报文段。若服务器端已经没有要向客户端发送的数据，其应用进程就通知TCP释放连接。**这时服务器端发出的连接释放报文段：FIN=1、 seq = y，服务器端进入LAST - ACK状态，等待客户端确认**

- **客户接收 FIN、回复 ACK**： 在客户端收到服务器端的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK = 1，确认号ACK = y + 1，**然后进入TIME-WAIT状态，必须再经过2MSL后，客户端才进入到CLOSED状态。MSL叫最长报文段寿命，一般为2分钟**，当服务器端收到客户端发出的确认，就进入CLOSED状态



### 为什么四次挥手？

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。**这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文**。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。



## TCP粘包/拆包问题



### 什么是粘包问题？

假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829204319.png" width = "400", height = "100"></img></div>

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829204206.png" width = "400", height = "100"></img></div>

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829204428.png" width = "400", height = "100"></img></div>

**接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包**。



### 为什么会发生粘包问题？

我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。

- **那么UDP是否会发生粘包或拆包的现象呢？答案是不会**。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，**因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题**。

- **TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界**；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能



### 什么时候会出现粘包/拆包问题？

- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包
- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包
- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包



### 解决方案

**归根结底就是一句话, 明确两个包之间的边界**

- **发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度**，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了
- **发送端将每个数据包封装为固定长度**（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来
- **可以在数据包之间设置边界，如添加特殊符号**，这样，接收端通过这个边界就可以将不同的数据包拆分开



## TCP协议如何保证可靠传输？

1. 应用数据被分割成TCP认为最适合发送的数据块。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
2. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
3. **流量控制：TCP 连接的每一方都有固定大小的缓冲空间RevWindow，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据**。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。**TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）**
4. **拥塞控制：** 当网络拥塞时，减少数据的发送。**主要通过慢开始、拥塞避免、快重传、快恢复算法控制**
5. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
6. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。



## ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）**是OSI模型中数据链路层和传输层的错误纠正协议之一**。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。**如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送**。ARQ包括停止等待ARQ协议和连续ARQ协议。



#### 停止等待ARQ协议

- 停止等待协议是为了实现可靠传输的，它的基本原理就是**每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组**
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；

**优点：** 简单

**缺点：** 信道利用率低，等待时间长

**1) 无差错情况:**

发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。

**2) 出现差错情况（超时重传）:**

停止等待协议中超时重传是指**只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）**。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。**连续 ARQ 协议** 可提高信道利用率。**发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了**。



#### 连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

**缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落。这时就有两种策略：**发送方对窗口中的分组全部重新发送（GBN协议）或者选择重新发送未收到的分组（SR协议）**



## 滑动窗口机制

滑动窗口协议（Sliding Window Protocol），属于TCP的一种应用，**用于网络数据传输时的流量控制，以避免拥塞的发生**。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。**因此该协议可以加速数据的传输，提高网络吞吐量，是流水线技术的体现**。

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829212444.png" width = "600", height = "300"></img></div>



### Go-Back-N

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829212714.png" width = "800", height = "200"></img></div>



**发送方：**

- 在分组头中规定一个k位的序号

- 窗口： 允许的连续未确认的报文
- ACK(n): 确认所有的报文直到（包含）序号n - “累积ACK”
- 对第一个发送未被确认的报文定时
- 超时(n): **重发窗口中的报文n及以上更高序号的报文(只有一个定时器记录最早的未被确认报文的发送时间)**

**接收方：**

- ACK-only: 总是为正确接收的最高序号的分组发送ACK
  - 可能生成重复的ACK(s)，只需要记住被期待接收的序号expectedseqnum
- 接收到失序分组: **丢弃(不缓冲) -> 没有接收缓冲区，重发最高序号分组的ACK**



<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829213400.png" width = "600", height = "500"></img></div>



### Selective Repeat

**接收方分别确认已经收到的分组**，必要时，缓冲报文, 最后按序提交给上层

**发送者只重发没有收到确认的分组**，对每个**没有确认的报文发送者都要启动一个定时器(每个未被确认的报文都有一个定时器)**

**发送窗口**：N 个连续序号，限制被发送的未确认的分组数量

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829213807.png" width = "700", height = "400"></img></div>

**发送方：**

- 从上层收到数据 ：如果下一个可用的序号在发送方窗口内，则将数据打包并发送,启动定时器
- 超时(n)：重发分组n, 重启定时器
- 收到ACK(n)在[sendbase,sendbase + N - 1]内：**标记分组n被接收，如果n是最小的未确认分组，则增加窗口基序号到下一个未被确认的序号**

**接收方：**

- 分组n的序号在[rcvbase, rcvbase+N-1]内：发送ACK(n)
  - **失序分组: 缓冲**
  - 有序分组: 交付上层 (包括已经缓冲的有序分组), 提高窗口到下一个没有接收的分组 

- 分组n在[rcvbase-N,rcvbase-1]内：发送ACK(n)

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829220326.png" width = "700", height = "400"></img></div>



## TCP拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。**拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载**。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829220819.png" width = "600", height = "300"></img></div>

为了进行拥塞控制，**TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化**。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829221423.png" width = "800", height = "100"></img></div>

**感知拥塞：**

丢失事件 = 超时或者 3 个重复的ACKsTCP 发送方在丢失事件发生后降低发送速率 (CongWin)

**对拥塞的反应：**

- 当超时事件发生时：CongWin 立即设置为 1个 MSS； 窗口开始指数增长（进入慢启动）

- 到达一个阈值后再线性增长
- 收到三个重复的确认时：CongWin 减半+3 (Reno版) 然后，窗口线性增长

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829222257.png" width = "800", height = "300"></img></div>

> 图中 TCP Reno版本有误，此时CongWin = CongWin / 2 + 3



- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。**经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍**

- **拥塞避免：** cwnd >= ssthresh 时，每经过一个往返时间RTT就把发送放的cwnd加1

  - **3个重复的ACK出现时,阈值置为 ssthresh = CongWin / 2 并且CongWin = CongWin / 2 + 3 or 1(根据不同TCP实现版本)**
  - **如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始**

- **快重传：** 当**出现了3个重复的ACK时，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段**

  <div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200829232421.png" width = "800", height = "400"></img></div>

  此时，**发送方收到了累计3个连续的针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段**。立即重传3号报文段（**所谓快重传就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传**），并且执行快速恢复算法

- **快速恢复**：发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段，于是不启动慢开始算法，执行快速恢复算法：发送方**将ssthresh值和拥塞窗口值CongWin调整为当前一半（TCP Reno 调整为一半加3），开始执行拥塞避免算法**。

