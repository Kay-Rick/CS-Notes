- [进程状态及转换](#进程状态及转换)
- [进程和程序的区别](#进程和程序的区别)
- [进程和线程](#进程和线程)
  - [两者比较](#两者比较)
  - [内核支持线程和用户级线程？](#内核支持线程和用户级线程)
- [上下文切换](#上下文切换)
- [进程同步经典问题](#进程同步经典问题)
  - [生产者-消费者问题](#生产者-消费者问题)
  - [哲学家进餐问题](#哲学家进餐问题)
  - [读者-写者问题](#读者-写者问题)
- [线程死锁](#线程死锁)
  - [产生死锁的必要条件](#产生死锁的必要条件)
  - [如何避免死锁？](#如何避免死锁)
  - [写一产生死锁的程序](#写一产生死锁的程序)
  - [破坏死锁](#破坏死锁)
- [处理机调度算法](#处理机调度算法)
  - [先来先服务算法(FCFS)](#先来先服务算法fcfs)
  - [短作业优先(SJF)](#短作业优先sjf)
  - [高响应比优先调度算法(HRRN)](#高响应比优先调度算法hrrn)
  - [时间片轮转(RR)](#时间片轮转rr)
  - [多级反馈队列调度算法(FB)](#多级反馈队列调度算法fb)
  - [最早截止时间优先算法(EDF)](#最早截止时间优先算法edf)
  - [最低松弛度优先算法(LLF)](#最低松弛度优先算法llf)

![image-20200902172230548](https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200902172232.png)



## 进程状态及转换

<div align = "center"><img src = "https://tva1.sinaimg.cn/large/006tNbRwly1g9zrtw49tuj30s40bm0y5.jpg" width = "600" height = "300"></img></div>

- 新建态：线程被创建，PCB被创建出来但还未加载到内存

- 就绪态：进程已经加载到内存，已经做好了准备，等待CPU进行调度

- 运行态：得到CPU的调度，进程正在执行

- 阻塞态：进程因为某些事件需要停止执行(IO操作等)

- 退出态：操作系统从可执行进程组中释放该进程，要么自己停止，要么因为某种原因被取消运行



## 进程和程序的区别



- **每个进程实体中包含了程序段和数据段这两个部分**，因此说进程与程序是紧密相关的。但从结构上看，进程实体中处理程序段和数据段外，还必须包含一个数据结构，即**进程控制块PCB**
- **进程是程序的一次执行过程，因此是动态的**。动态性还表现在进程由创建而产生、由调度而执行、由撤销而消亡，即他具有一定的生命期。而程序则只是一组指令的有序集合，并可永久地存放在某种介质上，其本身不具有运动的含义，因此是静态的。
- **多个进程实体可同时存放在内存中并发地执行，这正是引入进程的目的**。而程序的并发执行具有不可再现性，因此程序不能正确地并发执行
- **进程是一个能够独立运行、独立分配资源和独立接受调度的基本单位**。而程序因不具有PCB，故是不可能在多道程序环境下独立运行的
- **进程与程序不一一对应**。同一个程序的多次运行，将形成多个不同的进程；同一个程序的一次执行也可以产生多个不同的进程；而一个进程在其生命期的不同时候可以执行不同的程序。



## 进程和线程



### 两者比较

**线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程**。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反



<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200901162428.png" width = "550" height = "300"></img></div>

- **调度性**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- **并发性**：在引入线程的OS中，不仅进程间可以并发执行，而且在一个进程内的多个线程间也可以并发执行，因此比传统的OS具有更好的并发性
- **拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源
- **独立性**：每个进程都能独立地申请资源和独立地运行；但同一进程的多个线程则共享进程的内存地址空间和其他资源，它们之间的独立性比进程之间的独立性要低
- **开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
- **支持多处理系统**：传统的进程只能运行在一个处理机上；多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而使它们之间的同步和通信的实现也变得更为容易



### 内核支持线程和用户级线程？



<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200901163327.png" width = "600" height = "300"></img></div>

内核级线程是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，也是依靠内核实现的。

用户级线程仅存在于用户空间中，即每个线程控制块设置在用户空间中，所有对线程的操作也在用户空间中完成，而无需内核的帮助

- **内核支持**：用户级线程可在一个不支持线程的OS中实现，而内核支持线程则不然，它需要得到OS内核的支持
- **处理器分配**：在多处理机环境下，对纯粹的用户级线程来说，内核一次只为一个进程分配一个处理器，即进程无法享用多处理机带来的好处；而在设置有内核支持线程时，**内核可调度一个应用中的多个线程同时在多个处理器上并行运行，从而提高程序的运行速度和效率**。
- **调度和线程执行时间**：**对设置有内核支持的系统，系统的调度方式和算法与进程的调度十分相似，只不过调度的单位是线程**；而对**只设置了用户级现成的系统，内核调度的单位仍为进程**，当一进程得到CPU时，隶属于该进程的多个线程可通过用户带的线程调度分享内核分配给进程的CPU时间。因此，在条件相同的情况下，内核支持的线程通常比用户级线程得到更多的CPU执行时间。
- **切换速度**：用户级线程的切换，通常发生在一个应用程序的诸线程之间，**由于不需要陷入内核，而且切换的规则也相当简单，因此切换速度比内核支持线程至少快 一个数量级**。
- **系统调用**：在典型的OS中，许多系统调用都会引起阻塞。**当一个要加个用户级线程执行这些系统调用时，被阻塞的将是整个进程；而当一个内核支持线程执行这些系统调用时，内核只阻塞这个线程**，但仍可调度其所属进程的其他线程执行。





## 上下文切换

- 多线程编程中一般**线程的个数都大于 CPU 核心的个数**，而**一个 CPU 核心在任意时刻只能被一个线程使用**，为了让这些线程都能得到有效执行，CPU 采取的策略是为**每个线程分配时间片并轮转的形式**。当一个线程的时间片用完的时候就会**重新处于就绪状态让给其他线程使用**，这个过程就属于一次上下文切换。

- 总结说：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。



## 进程同步经典问题

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁

### 生产者-消费者问题

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200902151733.png" width = "700" height = "300"></img></div>

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

**因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问**。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。



```c++
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```



### 哲学家进餐问题

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200902144546.png" width = "400" height = "300"></img></div>

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

桌子上有5个碗和5只筷子。当一个哲学家思考时，他与相邻的两个哲学家不会互相影响；但当他进餐时，需同时获得最靠近他的、左右两只筷子，若其中一只筷子被相邻的哲学家拿走，他就必须等待，因此，他们互相制约

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐



```c++
#define N 5
#define LEFT (i + N - 1) % N 		// 左邻居
#define RIGHT (i + 1) % N    		// 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&mutex);
    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}

void eat(int i) {
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```



### 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```c++
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```





## 线程死锁

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。



### 产生死锁的必要条件

- **互斥条件**：该资源任意一个时刻只由一个线程占用。
- **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。



### 如何避免死锁？

- 破坏互斥条件：**没有办法破坏**，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）
- 破坏请求和保持条件：一次性申请所有的资源（银行家算法）
- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件




### 写一产生死锁的程序

``` java
public class DeadLockDemo {
    private static Object resource1 = new Object();		//资源 1
    private static Object resource2 = new Object();		//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);  
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```

输出：

```
Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
```

线程 A 通过 `synchronized (resource1) `获得 resource1 的监视器锁，然后通过`Thread.sleep(1000);`让线程 A 休眠 1s 为的是让**线程 B 得到执行然后获取到 resource2 的监视器锁**。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这**两个线程就会陷入互相等待的状态**，这也就产生了死锁。



### 破坏死锁

靠**按序申请资源来预防。按某一顺序申请资源**，释放资源则反序释放。破坏循环等待条件。

``` java
new Thread(() -> {
    synchronized (resource1) {
      	System.out.println(Thread.currentThread() + "get resource1");
        try {
          	Thread.sleep(1000);
        } catch (InterruptedException e) {
          	e.printStackTrace();
        }
        System.out.println(Thread.currentThread() + "waiting get resource2");
        synchronized (resource2) {
          	System.out.println(Thread.currentThread() + "get resource2");
        }
    }
}, "线程 2").start();
```

**线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了**。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。**然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了**。这样就破坏了破坏循环等待条件，因此避免了死锁。

​	

## 处理机调度算法



### 先来先服务算法(FCFS)

既可用于作业调度，也可用于进程调度。作业调度时，**优先选择后备作业中最先进入队列的作业**。进程调度时，每次调度从就绪队列中选择一个最先进入该队列的进程。

- **优点：简单、易于实现**
- **缺点：有利于长作业（进程），而不利于短作业（进程）**



### 短作业优先(SJF)

既可用于作业调度，也可用于进程调度。调度时：选择就绪队列中估计运行时间最短的进程投入执行。

- **优点：有效缩短作业的平均周转时间，提高系统的吞吐量**
- **缺点：不利于长作业和紧迫作业的运行**



###优先级调度算法(PSA)

既可用于作业调度，也可用于进程调度。**系统根据进程的紧迫程度赋予每个进程一个优先权，并将选择就绪队列中优先权最高的进程投入执行**。

**1)静态优先权**

在创建进程时，根据进程的类型、进程对资源的要求和用户的要求等确定他的优先权，以后该优先权便不再变化。

- **优点：简单易行**

- **缺点：随着进程的推进，其优先权可能与进程的情况不再相符**

**2)动态优先权**

在创建进程时确定的优先权可以随着进程的推进而改变。

- 优点：可以避免一个低优先权的进程长时间处于饥饿状态，又可防止一个长作业长期垄断处理机



### 高响应比优先调度算法(HRRN)

实际上是一种动态优先权调度算法，它以响应比作为时间或进程的动态优先权。

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200902165017.png" width = "400" height = "60"></img></div>



- **优点：是照顾短作业，又考虑到作业的等待时间，使长作业不会长期等待**
- **缺点：响应比的计算会增加系统的开销**



### 时间片轮转(RR)

每个进程**仅运行一个时间片**（一个较小的时间间隔，通常是10ms ~ 100ms），系统将所有的**就绪进程按FIFO规则排成一个队列，将CPU分配给队首进程**，且规定它最多只能连续执行一个时间片，若时间片用完时进程仍为完成，也必须将其插入就绪队列末尾，并把CPU交给下一个进程。属于抢占式调度方式。

**时间片大小的确定：**

太小：利于短作业，但增大调度和上下文切换频率，增大系统开销；
太长：退化为FCFS算法。
合适：略大于一次典型的交互所需的时间，使大多数交互式进程能在一个时间片内完成

- **优点：简单易行、平均响应时间短**
- **缺点：不利于处理紧急作业**



### 多级反馈队列调度算法(FB)

设置多个就绪队列，并为各个队列赋予不同的优先级。优先级愈高的队列的进程的执行时间片就愈小。
**新进程首先进入最高优先级的队列。每个队列采用FCFS算法**。队列中的**进程运行一个时间片后未结束则降级排到下一个队列的末尾**。最低优先权队列中的进程则按RR方式运行。**按队列优先级调度。只有比队列的优先级高的队列均空时，才运行该队列中的进程**。

<div align = "center"><img src = "https://kay-rick.oss-cn-beijing.aliyuncs.com/img/20200902170940.png" width = "500" height = "350"></img></div>

- **优点：短作业一次完成，响应时间性能好；中型作业周转时间不长；大型作业不会长期不处理**



### 最早截止时间优先算法(EDF)

> 实时系统：计算机**及时响应**外部事件的请求，**在规定的时间内完成对该事件的处理**，并控制所有实时设备和实时任务协调一致的运行。所谓实时任务是指具有及时性要求的、经常被重复执行的特定进程



该算法要求在系统中**保持一个实时任务就绪队列，该队列按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面**。调度程序总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。**即可采用非抢占调度方式，也可采用抢占调度方式**。



### 最低松弛度优先算法(LLF)

**松弛度 = 完成截至时间 – 剩余运行时间 – 当前时间** 
该算法**按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面（优先权高）**，调度程序总是选择就绪队列中的队首任务执行。通常采用抢占方式，当一任务的最低松弛度为0的时候，它便立即抢占CPU，以保证它的截止时间要求。

